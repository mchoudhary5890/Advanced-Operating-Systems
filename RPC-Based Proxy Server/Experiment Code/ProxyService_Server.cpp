// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.
#include "ProxyService.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include "RRPolicy.h"
#include "LRUPolicy.h"
#include "MAXSPolicy.h"
#include <iostream>
using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

using namespace  ::ProxyServer;
using namespace std;

int policy = 0;
size_t UserDefinedSize = 0;
long cacheHits = 0;
long totalBytesReturned = 0;
long bytesReturnedFromCache = 0;
long totalRequestCount = 0;

class ProxyServiceHandler : virtual public ProxyServiceIf {
 public:
  WebCache* webCacheObj;
  ProxyServiceHandler() {
    	switch(policy)
	{
		case 1:
			webCacheObj = new RRPolicy(UserDefinedSize);
			cout << "RRPolicy Object Created.\n";
			break;
		case 2:
			webCacheObj = new LRUPolicy(UserDefinedSize);
			cout << "LRUPolicy Object Created.\n";
			break;
		case 3:
			webCacheObj = new MAXSPolicy(UserDefinedSize);
			cout << "MAXSPolicy Object Created.\n";
			break;		
		default:	
			cout << "Please refer ReadMe file for the avaiable policies and corresponding input values.\n"; 
	}		
}

void fetchWebPage(std::string& _return, const std::string& URL) 
{
	cout << "Request to Fetch webPage: " << URL << "\n";
	totalRequestCount++;
        std::string fetchedPage;
	if(webCacheObj->isWebCacheEmpty())
    	{
		cout << "The WebCache is Empty. Fetching from Web\n"; 
		fetchedPage = webCacheObj->fetchFromWeb(URL);
		if(fetchedPage.size() <= webCacheObj->getMaxWebCacheSize())
		{
			cout << "Caching the Fetched Web Page.\n";
			webCacheObj->cacheWebPage(URL,fetchedPage);
		}
	}
	else
	{
		cout << "The WebCache is not empty. Trying to Fetch from WebCache.\n";
		fetchedPage = webCacheObj->fetchFromWebCache(URL);
		if (fetchedPage.size()==0)
		{
			cout << "The requested page is not present in the cache. Trying to Fetch from Web.\n";
			fetchedPage = webCacheObj->fetchFromWeb(URL);		
			if(fetchedPage.size() <= webCacheObj->getMaxWebCacheSize())
			{
				cout << "Caching the Fetched Web Page.\n";
				webCacheObj->cacheWebPage(URL, fetchedPage);
			}
		}
		else
		{
			cacheHits++;
			bytesReturnedFromCache += fetchedPage.size();
		}
	}
   	if(fetchedPage.size())
         {
		totalBytesReturned += fetchedPage.size();
                cout << "Size of web page is " <<fetchedPage.size()<<".\n";
		cout << "Total Requests: " << totalRequestCount << ".\n";
		cout << "Total Hits: "<< cacheHits << ".\n";
		cout << "totalBytesReturned: "<<totalBytesReturned << ".\n";
		cout << "bytesReturnedFromCache" << bytesReturnedFromCache << ".\n";
		cout << "cacheEntryRemovalCount: "<< webCacheObj->getCacheEntryRemovalCount() << ".\n";
  		_return = fetchedPage.c_str();			
         }
  }
};

int main(int argc, char **argv) 
{
  if(argc!=3)
  {
  	std::cout << "Usage: " << argv[0] << "<Max Cache Size> " << " <Replacement Policy> "; 
	return 0;
  }		
  int port = 9090;
  policy = atoi(argv[2]);
  UserDefinedSize = atoi(argv[1]); 
  shared_ptr<ProxyServiceHandler> handler(new ProxyServiceHandler());
  shared_ptr<TProcessor> processor(new ProxyServiceProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());
  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  server.serve();
  return 0;
}
